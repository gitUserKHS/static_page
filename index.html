<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mini Minecraft Creative</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #joystick {
      position: fixed;
      left: 20px;
      bottom: 20px;
      width: 80px;
      height: 80px;
      background: rgba(0,0,0,0.3);
      border-radius: 50%;
      touch-action: none;
    }
    #joystick-handle {
      position: absolute;
      left: 30px;
      top: 30px;
      width: 20px;
      height: 20px;
      background: #fff;
      border-radius: 50%;
      pointer-events: none;
    }
    #breakBtn, #placeBtn {
      position: fixed;
      right: 20px;
      width: 60px;
      height: 60px;
      border-radius: 30px;
      background: rgba(0,0,0,0.4);
      color: #fff;
      border: none;
      font-size: 12px;
      touch-action: manipulation;
    }
    #breakBtn { bottom: 20px; }
    #placeBtn { bottom: 90px; }
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 2px;
      height: 2px;
      margin-left: -1px;
      margin-top: -1px;
      background: #fff;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="joystick"><div id="joystick-handle"></div></div>
  <button id="breakBtn">Break</button>
  <button id="placeBtn">Place</button>
  <div id="crosshair"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/simplex-noise.js"></script>
  <script>
    // ===== 기본 설정 =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 20, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ===== 조명 =====
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    // ===== 컨트롤 =====
    const controls = new THREE.PointerLockControls(camera, renderer.domElement);
    const player = controls.getObject();
    scene.add(player);
    document.body.addEventListener('click', () => controls.lock());

    const move = { forward: 0, backward: 0, left: 0, right: 0 };
    document.addEventListener('keydown', e => {
      switch(e.code){
        case 'KeyW': move.forward = 1; break;
        case 'KeyS': move.backward = 1; break;
        case 'KeyA': move.left = 1; break;
        case 'KeyD': move.right = 1; break;
        case 'Space': if(canJump) velocity.y = 5; canJump = false; break;
      }
    });
    document.addEventListener('keyup', e => {
      switch(e.code){
        case 'KeyW': move.forward = 0; break;
        case 'KeyS': move.backward = 0; break;
        case 'KeyA': move.left = 0; break;
        case 'KeyD': move.right = 0; break;
      }
    });

    // ===== 모바일용 가상 조이스틱 =====
    const joystick = document.getElementById('joystick');
    const handle = document.getElementById('joystick-handle');
    let touchId = null;
    let joy = { x: 0, y: 0 };
    const MAX_DIST = 30;

    joystick.addEventListener('touchstart', e => {
      if (touchId === null) {
        touchId = e.changedTouches[0].identifier;
        handle.style.left = '30px';
        handle.style.top = '30px';
      }
    });

    joystick.addEventListener('touchmove', e => {
      for (let t of e.changedTouches) {
        if (t.identifier === touchId) {
          const rect = joystick.getBoundingClientRect();
          const x = t.clientX - rect.left - rect.width / 2;
          const y = t.clientY - rect.top - rect.height / 2;
          const dist = Math.min(Math.sqrt(x*x + y*y), MAX_DIST);
          const angle = Math.atan2(y, x);
          joy.x = (dist / MAX_DIST) * Math.cos(angle);
          joy.y = (dist / MAX_DIST) * Math.sin(angle);
          handle.style.left = 30 + joy.x * MAX_DIST + 'px';
          handle.style.top = 30 + joy.y * MAX_DIST + 'px';
        }
      }
    });

    const endJoy = () => {
      touchId = null;
      joy.x = joy.y = 0;
      handle.style.left = '30px';
      handle.style.top = '30px';
    };

    joystick.addEventListener('touchend', endJoy);
    joystick.addEventListener('touchcancel', endJoy);

    // ===== 월드 생성 (Perlin Noise) =====
    const blockGeo = new THREE.BoxGeometry(1,1,1);
    const blockMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
    const blocks = {};
    const blocksGroup = new THREE.Group();
    scene.add(blocksGroup);
    const simplex = new SimplexNoise();
    const worldSize = 20;

    for (let x = -worldSize; x <= worldSize; x++) {
      for (let z = -worldSize; z <= worldSize; z++) {
        const height = Math.floor((simplex.noise2D(x/10, z/10) + 1) * 3);
        for (let y = -1; y < height; y++) {
          const block = new THREE.Mesh(blockGeo, blockMat);
          block.position.set(x, y, z);
          const key = `${x},${y},${z}`;
          block.userData.key = key;
          blocks[key] = block;
          blocksGroup.add(block);
        }
      }
    }

    // ===== 플레이어 물리 =====
    let velocity = new THREE.Vector3();
    const clock = new THREE.Clock();
    let canJump = false;
    const gravity = 9.8;

    function hasBlock(x,y,z){
      return blocks[`${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`];
    }

    function animate(){
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      velocity.y -= gravity * delta;

      let forward = move.forward - move.backward + joy.y;
      let strafe = move.right - move.left + joy.x;
      const speed = 5;
      const vx = -strafe * speed * delta;
      const vz = -forward * speed * delta;

      const pos = player.position;
      if (!hasBlock(pos.x + vx, pos.y, pos.z) && !hasBlock(pos.x + vx, pos.y - 1.8, pos.z)) pos.x += vx;
      if (!hasBlock(pos.x, pos.y, pos.z + vz) && !hasBlock(pos.x, pos.y - 1.8, pos.z + vz)) pos.z += vz;

      pos.y += velocity.y * delta;
      if (hasBlock(pos.x, pos.y - 1.8, pos.z)) {
        pos.y = Math.floor(pos.y - 1.8) + 1 + 1.8;
        velocity.y = 0;
        canJump = true;
      } else {
        canJump = false;
      }

      renderer.render(scene, camera);
    }
    animate();

    // ===== 블록 파괴 및 설치 =====
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function breakBlock(){
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(blocksGroup.children);
      if(intersects.length){
        const obj = intersects[0].object;
        blocksGroup.remove(obj);
        delete blocks[obj.userData.key];
      }
    }
    function placeBlock(){
      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(blocksGroup.children);
      if(intersects.length){
        const hit = intersects[0];
        const pos = hit.object.position.clone().add(hit.face.normal);
        const key = `${pos.x},${pos.y},${pos.z}`;
        if(!blocks[key]){
          const block = new THREE.Mesh(blockGeo, blockMat);
          block.position.copy(pos);
          block.userData.key = key;
          blocks[key] = block;
          blocksGroup.add(block);
        }
      }
    }
    window.addEventListener('mousedown', e => {
      if(e.button === 0) breakBlock();
      if(e.button === 2) placeBlock();
    });
    window.addEventListener('contextmenu', e => e.preventDefault());
    document.getElementById('breakBtn').addEventListener('touchstart', breakBlock);
    document.getElementById('placeBtn').addEventListener('touchstart', placeBlock);

    // ===== 화면 크기 조정 =====
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
