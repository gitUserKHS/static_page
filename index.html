<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"/>
  <title>Mini Minecraft – Chunks + Fly</title>
  <style>
    :root{--u:bg rgba(0,0,0,.4);--u:fg #fff}
    html,body{margin:0;height:100%;overflow:hidden;background:#000}
    canvas{display:block}

    /* HUD */
    #hud{position:fixed;left:12px;top:12px;padding:8px 10px;color:#fff;
      font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:var(--u:bg);
      border-radius:8px;user-select:none;max-width:min(90vw,440px)}
    #crosshair{position:fixed;left:50%;top:50%;width:14px;height:14px;margin:-7px 0 0 -7px;pointer-events:none}
    #crosshair:before,#crosshair:after{content:"";position:absolute;left:50%;top:50%;background:#fff;transform:translate(-50%,-50%)}
    #crosshair:before{width:14px;height:2px} #crosshair:after{width:2px;height:14px}

    /* Mobile joystick */
    #joystick{position:fixed;left:18px;bottom:18px;width:96px;height:96px;border-radius:50%;
      background:rgba(255,255,255,.08);touch-action:none;backdrop-filter:blur(2px)}
    #joystick-handle{position:absolute;left:38px;top:38px;width:20px;height:20px;border-radius:50%;background:#fff;box-shadow:0 0 10px rgba(255,255,255,.6);pointer-events:none}

    /* Mobile buttons */
    .act{position:fixed;right:18px;width:64px;height:64px;border-radius:50%;border:0;color:#fff;background:var(--u:bg);font-weight:700;font-size:12px;touch-action:manipulation}
    #breakBtn{bottom:18px}
    #placeBtn{bottom:96px}
    #flyBtn{bottom:174px}
    .fly-vert{position:fixed;right:96px;width:44px;height:44px;border-radius:22px;border:0;color:#fff;background:var(--u:bg);font-weight:700;font-size:14px;touch-action:manipulation;display:none}
    #flyUp{bottom:174px} #flyDown{bottom:126px}

    .mobile-only{display:none}
    @media (pointer:coarse){.mobile-only{display:block} #hud .desktop-tip{display:none}}
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Mini Minecraft</b></div>
    <div class="desktop-tip">Desktop: 클릭→마우스락 • WASD 이동 • Space 점프 • Shift 아래(비행) • F 비행 토글 • 좌클릭 파괴 • 우클릭 설치</div>
    <div>Mobile: 화면 드래그 회전 • 조이스틱 이동 • Break/Place • Fly/↑/↓</div>
    <div id="perf"></div>
  </div>

  <!-- Mobile UI -->
  <div id="joystick" class="mobile-only"><div id="joystick-handle"></div></div>
  <button id="breakBtn" class="act mobile-only">Break</button>
  <button id="placeBtn" class="act mobile-only">Place</button>
  <button id="flyBtn"   class="act mobile-only">Fly</button>
  <button id="flyUp"    class="fly-vert mobile-only">↑</button>
  <button id="flyDown"  class="fly-vert mobile-only">↓</button>

  <div id="crosshair"></div>

  <!-- Absolute ESM URLs (no import map) -->
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js";
    import { createNoise2D } from "https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/dist/esm/simplex-noise.js";

    // ---------- Basic ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.rotation.order = "YXZ"; // yaw->pitch

    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(0.6,1,0.4).multiplyScalar(30);
    scene.add(sun);
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));

    // Player rig (yaw node -> pitch/camera)
    const player = new THREE.Object3D();
    const pitchNode = new THREE.Object3D();
    pitchNode.add(camera);
    player.add(pitchNode);
    scene.add(player);

    player.position.set(0, 20, 0);
    camera.position.set(0, 1.6, 0);

    // ---------- Input ----------
    const key = { w:0,a:0,s:0,d:0, space:0, shift:0 };
    let fly = false;
    addEventListener("keydown", e=>{
      switch(e.code){
        case "KeyW": key.w=1; break; case "KeyS": key.s=1; break;
        case "KeyA": key.a=1; break; case "KeyD": key.d=1; break;
        case "Space": key.space=1; break; case "ShiftLeft": case "ShiftRight": key.shift=1; break;
        case "KeyF": fly=!fly; vel.y=0; updateMobileFlyUI(); break;
      }
    });
    addEventListener("keyup", e=>{
      switch(e.code){
        case "KeyW": key.w=0; break; case "KeyS": key.s=0; break;
        case "KeyA": key.a=0; break; case "KeyD": key.d=0; break;
        case "Space": key.space=0; break; case "ShiftLeft": case "ShiftRight": key.shift=0; break;
      }
    });

    const isTouch = matchMedia("(pointer:coarse)").matches || "ontouchstart" in window;
    const joy = { x:0, y:0 };
    if (isTouch){
      const joyEl = document.getElementById("joystick");
      const handle = document.getElementById("joystick-handle");
      const MAX=36; let tid=null;
      joyEl.addEventListener("touchstart", e=>{ if(tid===null) tid=e.changedTouches[0].identifier; }, {passive:false});
      joyEl.addEventListener("touchmove", e=>{
        for(const t of e.changedTouches) if(t.identifier===tid){
          const r=joyEl.getBoundingClientRect();
          const x=t.clientX-(r.left+r.width/2), y=t.clientY-(r.top+r.height/2);
          const len=Math.min(Math.hypot(x,y),MAX), ang=Math.atan2(y,x);
          joy.x=(len/MAX)*Math.cos(ang); joy.y=(len/MAX)*Math.sin(ang);
          handle.style.left=(r.width/2-10)+joy.x*MAX+"px";
          handle.style.top =(r.height/2-10)+joy.y*MAX+"px";
          e.preventDefault();
        }
      }, {passive:false});
      const end=()=>{ tid=null; joy.x=joy.y=0; handle.style.left="38px"; handle.style.top="38px"; };
      joyEl.addEventListener("touchend", end); joyEl.addEventListener("touchcancel", end);

      // Mobile actions
      document.getElementById("flyBtn").addEventListener("touchstart", ()=>{ fly=!fly; vel.y=0; updateMobileFlyUI(); }, {passive:true});
      document.getElementById("flyUp").addEventListener("touchstart", ()=>{ fly=true; key.space=1; updateMobileFlyUI(); }, {passive:true});
      document.getElementById("flyUp").addEventListener("touchend",   ()=>{ key.space=0; }, {passive:true});
      document.getElementById("flyDown").addEventListener("touchstart", ()=>{ fly=true; key.shift=1; updateMobileFlyUI(); }, {passive:true});
      document.getElementById("flyDown").addEventListener("touchend",   ()=>{ key.shift=0; }, {passive:true});
    }
    function updateMobileFlyUI(){
      const up = document.getElementById("flyUp");
      const dn = document.getElementById("flyDown");
      if (isTouch){ up.style.display = dn.style.display = fly ? "block" : "none"; }
    }

    // Desktop look: pointer lock
    if (!isTouch){
      document.body.addEventListener("click", ()=>{ document.body.requestPointerLock?.(); });
      addEventListener("mousemove", e=>{
        if (document.pointerLockElement===document.body){
          yaw -= e.movementX*0.0025;
          pitch = clamp(pitch - e.movementY*0.0025, -Math.PI/2+0.01, Math.PI/2-0.01);
        }
      });
    }
    // Mobile drag look
    if (isTouch){
      let dragging=false, px=0, py=0;
      addEventListener("touchstart", e=>{
        const t=e.target;
        if (t.id==="joystick"||t.id==="joystick-handle"||t.classList.contains("act")||t.classList.contains("fly-vert")) return;
        dragging=true; px=e.touches[0].clientX; py=e.touches[0].clientY;
      }, {passive:true});
      addEventListener("touchmove", e=>{
        if (!dragging) return;
        const cx=e.touches[0].clientX, cy=e.touches[0].clientY;
        const dx=cx-px, dy=cy-py; px=cx; py=cy;
        yaw -= dx*0.005; pitch = clamp(pitch - dy*0.005, -Math.PI/2+0.01, Math.PI/2-0.01);
      }, {passive:true});
      addEventListener("touchend", ()=>dragging=false, {passive:true});
      addEventListener("touchcancel", ()=>dragging=false, {passive:true});
    }

    // ---------- Look state ----------
    let yaw=0, pitch=0;
    const clamp=(v,lo,hi)=>Math.max(lo,Math.min(hi,v));
    function applyLook(){ player.rotation.y = yaw; camera.rotation.x = pitch; }

    // ---------- World: chunked generation ----------
    const CHUNK=16, RADIUS=2; // chunk radius around player
    const blockGeo = new THREE.BoxGeometry(1,1,1);
    const MAT_DIRT  = new THREE.MeshLambertMaterial({ color:0x8B5A2B });
    const MAT_GRASS = new THREE.MeshLambertMaterial({ color:0x4CAF50 });

    const blocksGroup = new THREE.Group(); // parent for all chunks
    scene.add(blocksGroup);

    const blocks = new Set();           // occupancy: "x,y,z"
    const chunks = new Map();           // "cx,cz" -> THREE.Group
    const noise2D = createNoise2D();

    function keyOf(x,y,z){ return `${x},${y},${z}`; }
    function hasBlock(x,y,z){ return blocks.has(keyOf(Math.floor(x),Math.floor(y),Math.floor(z))); }
    function chunkKey(cx,cz){ return `${cx},${cz}`; }

    function heightAt(x,z){
      // simple layered noise for nicer terrain
      const h = (noise2D(x/18, z/18)+1)*4 + (noise2D(x/48, z/48)+1)*2;
      return Math.floor(h - 2); // can go negative a bit
    }

    function genChunk(cx,cz){
      const k = chunkKey(cx,cz);
      if (chunks.has(k)) return;
      const g = new THREE.Group(); g.userData.cx=cx; g.userData.cz=cz;
      // build columns
      for (let lx=0; lx<CHUNK; lx++){
        for (let lz=0; lz<CHUNK; lz++){
          const x = cx*CHUNK + lx;
          const z = cz*CHUNK + lz;
          const h = heightAt(x,z);
          for (let y=-2; y<=h; y++){
            const m = new THREE.Mesh(blockGeo, y===h ? MAT_GRASS : MAT_DIRT);
            m.position.set(x,y,z);
            g.add(m);
            blocks.add(keyOf(x,y,z));
          }
        }
      }
      chunks.set(k,g);
      blocksGroup.add(g);
    }

    function unloadFarChunks(centerCx, centerCz){
      for (const [k,g] of chunks){
        const dx = g.userData.cx - centerCx;
        const dz = g.userData.cz - centerCz;
        if (Math.max(Math.abs(dx), Math.abs(dz)) > RADIUS+1){
          // remove occupancy
          for (const m of g.children){
            blocks.delete(keyOf(m.position.x, m.position.y, m.position.z));
          }
          blocksGroup.remove(g);
          chunks.delete(k);
          g.traverse(o=>{ if (o.isMesh) o.geometry.dispose?.(); });
        }
      }
    }

    let lastChunkCx=Infinity, lastChunkCz=Infinity;
    function ensureWorldAround(px,pz){
      const cx = Math.floor(px/CHUNK);
      const cz = Math.floor(pz/CHUNK);
      if (cx===lastChunkCx && cz===lastChunkCz) return;
      lastChunkCx=cx; lastChunkCz=cz;
      for (let dz=-RADIUS; dz<=RADIUS; dz++){
        for (let dx=-RADIUS; dx<=RADIUS; dx++){
          genChunk(cx+dx, cz+dz);
        }
      }
      unloadFarChunks(cx,cz);
    }

    // initial chunks
    ensureWorldAround(player.position.x, player.position.z);

    // ---------- Physics / movement ----------
    const clock = new THREE.Clock();
    const speedWalk=6, speedFly=10, gravity=18, eye=1.8;
    let canJump=false;
    const vel = new THREE.Vector3();

    function moveAndCollide(dt){
      // Basis from yaw: forward = (sin yaw, 0, -cos yaw), right = (cos yaw, 0, sin yaw)
      const fwX = Math.sin(yaw), fwZ = -Math.cos(yaw);
      const rtX = Math.cos(yaw), rtZ =  Math.sin(yaw);

      const inFwd = (key.w - key.s) + (isTouch? joy.y:0);
      const inStr = (key.d - key.a) + (isTouch? joy.x:0);

      // combine
      let dx = inFwd*fwX + inStr*rtX;
      let dz = inFwd*fwZ + inStr*rtZ;

      // normalize diagonal
      const len = Math.hypot(dx,dz);
      if (len>0){ dx/=len; dz/=len; }

      const spd = fly ? speedFly : speedWalk;
      dx *= spd*dt; dz *= spd*dt;

      // vertical
      if (fly){
        vel.y = (key.space?1:0) - (key.shift?1:0); // Space up / Shift down
        vel.y *= speedFly; // units/s
      }else{
        vel.y -= gravity*dt;
        if (key.space && canJump){ vel.y = 7; canJump=false; }
      }

      const pos = player.position;

      // horizontal collision (keep for fly too so we don't clip)
      if (!hasBlock(pos.x + dx, pos.y, pos.z) && !hasBlock(pos.x + dx, pos.y - eye, pos.z)) pos.x += dx;
      if (!hasBlock(pos.x, pos.y, pos.z + dz) && !hasBlock(pos.x, pos.y - eye, pos.z + dz)) pos.z += dz;

      // vertical
      pos.y += vel.y*dt;
      if (!fly){
        if (hasBlock(pos.x, pos.y - eye, pos.z)){
          pos.y = Math.floor(pos.y - eye) + 1 + eye;
          vel.y = 0; canJump = true;
        }else{
          canJump = false;
        }
      }
    }

    // ---------- Build / break ----------
    const raycaster = new THREE.Raycaster();
    const center = new THREE.Vector2(0,0);

    function breakBlock(){
      raycaster.setFromCamera(center, camera);
      const hits = raycaster.intersectObjects(blocksGroup.children, true);
      if (hits.length){
        const obj = hits[0].object;
        const p = obj.position;
        blocks.delete(keyOf(p.x,p.y,p.z));
        obj.parent.remove(obj);
        obj.geometry.dispose?.();
      }
    }
    function placeBlock(){
      raycaster.setFromCamera(center, camera);
      const hits = raycaster.intersectObjects(blocksGroup.children, true);
      if (hits.length){
        const hit = hits[0];
        const pos = hit.object.position.clone().add(hit.face.normal);
        pos.x = Math.round(pos.x); pos.y = Math.round(pos.y); pos.z = Math.round(pos.z);
        const k = keyOf(pos.x,pos.y,pos.z);
        if (!blocks.has(k)){
          const top = !hasBlock(pos.x, pos.y+1, pos.z);
          const cube = new THREE.Mesh(blockGeo, top?MAT_GRASS:MAT_DIRT);
          cube.position.copy(pos);
          // put into its chunk group
          const cx = Math.floor(pos.x/CHUNK), cz = Math.floor(pos.z/CHUNK);
          const g = chunks.get(chunkKey(cx,cz)) ?? blocksGroup; // fallback
          g.add(cube);
          blocks.add(k);
        }
      }
    }

    // mouse for desktop
    addEventListener("mousedown", e=>{
      if (isTouch) return;
      if (e.button===0) breakBlock();
      if (e.button===2) placeBlock();
    });
    addEventListener("contextmenu", e=>e.preventDefault());

    // mobile actions
    if (isTouch){
      document.getElementById("breakBtn").addEventListener("touchstart", breakBlock, {passive:true});
      document.getElementById("placeBtn").addEventListener("touchstart", placeBlock, {passive:true});
    }

    // ---------- Resize ----------
    addEventListener("resize", ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ---------- Main loop ----------
    const perfEl = document.getElementById("perf");
    let acc=0, frames=0, lastPerf=0;

    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      applyLook();
      moveAndCollide(dt);
      ensureWorldAround(player.position.x, player.position.z);
      renderer.render(scene, camera);

      acc+=dt; frames++;
      if (acc>0.25){
        const fps=Math.round(frames/acc);
        if (performance.now()-lastPerf>250){ perfEl.textContent=`FPS: ${fps} | Fly: ${fly?"ON":"OFF"}`; lastPerf=performance.now(); }
        acc=0; frames=0;
      }
    }
    animate();
  </script>
</body>
</html>
